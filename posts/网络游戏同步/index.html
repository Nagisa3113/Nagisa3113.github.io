<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>网络游戏同步 | Nostalgia</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="浅谈网络游戏开发中的TCP/UDP、帧同步/状态同步以及预测、快照和回滚">
<meta name="generator" content="Hugo 0.110.0">


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />

 
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'your-google-analytics-id', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>




  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>




  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	

	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">网络游戏同步</h1>

    <div class="tip">
        <time datetime="2020-04-16 00:00:00 &#43;0000 UTC">Apr 16, 2020</time>
        <span class="split">
          ·
        </span>
        <span>
          2680 words
        </span>
        <span class="split">
          ·
        </span>
        <span>
          6 minute read
        </span>
    </div>

    
    
        
  
    <aside class="toc">
      <details>
          <summary>Table of Contents
          </summary>
          <div>
              <nav id="TableOfContents">
  <ul>
    <li><a href="#网络拓扑结构">网络拓扑结构</a></li>
    <li><a href="#网络传输协议">网络传输协议</a></li>
    <li><a href="#tcp">TCP</a></li>
    <li><a href="#udp">UDP</a></li>
    <li><a href="#网络同步模型network-model">网络同步模型(Network Model)</a></li>
    <li><a href="#帧同步">帧同步</a>
      <ul>
        <li><a href="#优点">优点</a></li>
        <li><a href="#缺点">缺点</a></li>
        <li><a href="#帧同步buffer">帧同步buffer</a></li>
      </ul>
    </li>
    <li><a href="#状态同步">状态同步</a>
      <ul>
        <li><a href="#优点-1">优点</a></li>
        <li><a href="#缺点-1">缺点</a></li>
      </ul>
    </li>
    <li><a href="#预测回滚与快照">预测、回滚与快照</a></li>
    <li><a href="#逻辑表示分离与插值">逻辑表示分离与插值</a></li>
    <li><a href="#守望先锋">《守望先锋》</a></li>
    <li><a href="#王者荣耀">《王者荣耀》</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
          </div>
      </details>
    </aside>
  


    


    <div class="content">
      <p>浅谈网络游戏开发中的TCP/UDP、帧同步/状态同步以及预测、快照和回滚</p>
<h2 id="网络拓扑结构">网络拓扑结构 <a href="#%e7%bd%91%e7%bb%9c%e6%8b%93%e6%89%91%e7%bb%93%e6%9e%84" class="anchor">🔗</a></h2><ul>
<li>Peer-to-Peer P2P 网状结构，一般是所有客户端两两链接，传统的局域网游戏</li>
<li>Client-Server CS 星状结构，至少有一部服务器，客户端只与服务器连接</li>
</ul>
<h2 id="网络传输协议">网络传输协议 <a href="#%e7%bd%91%e7%bb%9c%e4%bc%a0%e8%be%93%e5%8d%8f%e8%ae%ae" class="anchor">🔗</a></h2><p>UDP/TCP属于传输层（Transport Layer）</p>
<h2 id="tcp">TCP <a href="#tcp" class="anchor">🔗</a></h2><ul>
<li>保序可靠传输（Sequenced Reliable Transmission）</li>
<li>传输慢，因为要保证正确性</li>
<li>连接慢，首次通信需要进行著名的三次握手连接，复杂且黑盒，难扩展，</li>
<li>报头大，不适用于数据包数量多的情况</li>
</ul>
<h2 id="udp">UDP <a href="#udp" class="anchor">🔗</a></h2><ul>
<li>不可靠不保序传输（Unsequenced Unreliable Transmission），即传输不保序，也不确保可达，某个具体数据包在传输的过程中，是可能丢失的；也可能数据包到达了，但数据出错从而校验失败，也被Socket丢弃掉</li>
<li>传输快，Socket不会浪费时间和带宽，对丢失的数据包进行重传</li>
<li>不需要建立连接，收发双方每次通信都是无状态的</li>
<li>简单，上层应用能按需实现额外的传输特性（QoS），很多游戏会自己开发可靠传输、冗余的UDP</li>
<li>报头小，节省带宽</li>
</ul>
<p>大部分游戏使用的都是UDP，而TCP适合节奏慢的游戏，如炉石传说等回合制游戏，值得一提的是魔兽世界用的是TCP</p>
<h2 id="网络同步模型network-model">网络同步模型(Network Model) <a href="#%e7%bd%91%e7%bb%9c%e5%90%8c%e6%ad%a5%e6%a8%a1%e5%9e%8bnetwork-model" class="anchor">🔗</a></h2><ul>
<li>确定性帧同步(deterministic lockstep) 常用于格斗、竞速、即时战略游戏。如星际争霸、魔兽争霸</li>
<li>快照插值(snapshot interpolation) FPS经典同步模型，《Quake》最早采用，后续众多FPS在之上做了改进</li>
<li>状态同步(state synchronization) 有点像是快照插值的改进版，Overwatch所采用的</li>
</ul>
<p>一般情况下我们谈论的只有两类：帧同步(lockstep)和状态同步(state synchronization)</p>
<h2 id="帧同步">帧同步 <a href="#%e5%b8%a7%e5%90%8c%e6%ad%a5" class="anchor">🔗</a></h2><p>是锁步同步(LockStep)的改进版本，它只同步状态变化的原因，如玩家的按键输入，服务器以固定的帧率收集每个客户端的输入，然后把这些输入广播给所有的客户端，由于每个操作指令到达所有客户端的时间（帧）是一样的，所以每个客户端运算结果也是一样的。为了保证游戏的公平性，如果一个玩家掉线了，其他玩家就会等待，例如有的外挂会等待其他客户端的帧都到达后才发送自己的帧。</p>
<p>它要求各个客户端的运算逻辑严格相同，否则一点的误差将会导致蝴蝶效应，解决方法：</p>
<ul>
<li>使用定点数代替浮点数，通常会使用第三方库</li>
<li>使用统一的随机数种子</li>
<li>确定性的容器算法，如保证排序的稳定性</li>
</ul>
<h3 id="优点">优点 <a href="#%e4%bc%98%e7%82%b9" class="anchor">🔗</a></h3><ol>
<li>开发效率高</li>
<li>更强的打击感 客户端接受指令后就可以单独进行画面渲染，格斗游戏使用的都是帧同步</li>
<li>流量消耗稳定 魔兽争霸的录像只有几百k，因为只记录了输入序列</li>
</ol>
<h3 id="缺点">缺点 <a href="#%e7%bc%ba%e7%82%b9" class="anchor">🔗</a></h3><ol>
<li>网络要求高，一般都使用UDP保证更低的延迟， 帧同步是锁帧的，如果有网络的抖动，一段时间调用次数不稳定，网络的延迟就会挤压，引起卡顿</li>
<li>安全性低，反外挂能力弱，所有玩家的数据都会被发送到客户端，逻辑运算在客户端里，可以轻易的进行内存修改</li>
<li>断线重连时间长，需要将游戏开始到当前时间的全部帧数据进行计算</li>
<li>性能优化难</li>
</ol>
<h3 id="帧同步buffer">帧同步buffer <a href="#%e5%b8%a7%e5%90%8c%e6%ad%a5buffer" class="anchor">🔗</a></h3><p>每个玩家的输入会发给所有客户端，服务器会按照一定的频率给帧编号，只有之后某一帧数据来到时才能执行当前帧，</p>
<p>buffer是一个帧队列的缓冲区，它可以根据网络情况动态改变大小</p>
<ul>
<li>buffer很小时，得到帧数据时可以立即执行，不需要等待，延迟就低，但如果下一帧一直不来，就不能执行当前帧，就会产生抖动</li>
<li>buffer很大时，画面不抖动了，但延迟会增加</li>
</ul>
<h2 id="状态同步">状态同步 <a href="#%e7%8a%b6%e6%80%81%e5%90%8c%e6%ad%a5" class="anchor">🔗</a></h2><p>所有逻辑运算在某个权威主机上执行，再下发到各个客户端中，考虑具体的网络拓扑结构，通常在服务器(Server)进行状态计算，在也称为C-S同步(Client-Server)</p>
<h3 id="优点-1">优点 <a href="#%e4%bc%98%e7%82%b9-1" class="anchor">🔗</a></h3><ul>
<li>安全性高，所有计算在服务器端执行</li>
<li>网络要求宽松，抖动包适应性强</li>
<li>断线重连快，只需要将最新状态下发给客户端</li>
<li>利于性能优化，在客户端中看不到的角色可以不用创建</li>
</ul>
<h3 id="缺点-1">缺点 <a href="#%e7%bc%ba%e7%82%b9-1" class="anchor">🔗</a></h3><ul>
<li>开发效率低</li>
<li>动作类游戏打击感和精确性差</li>
<li>流量随着游戏复杂度而逐渐增长</li>
</ul>
<p><p class="markdown-image">
  <img src="https://pic1.zhimg.com/80/v2-5a11925f93130d3c315300b9055baac0_1440w.jpg" alt="img"  />
</p></p>
<h2 id="预测回滚与快照">预测、回滚与快照 <a href="#%e9%a2%84%e6%b5%8b%e5%9b%9e%e6%bb%9a%e4%b8%8e%e5%bf%ab%e7%85%a7" class="anchor">🔗</a></h2><p>前面说到，帧同步要等待服务器的回包，这就会严重影响游戏的体验，所以即使在延迟高的网络条件下,玩家在按下按键后，客户端也要立即做出响应，保证本地玩家感觉不卡</p>
<p>于是很多FPS游戏会对玩家的操作进行预测，不用每次都等待服务器的回包，玩家按下按键就会立刻有反应，无论网络情况，这会使得客户端永远领先服务器。</p>
<p>举个例子，当客户端运行至41帧时，若网络延迟，未能收到服务器传来的第41帧数据客户端会通过最后几帧的信息，“预测”玩家在下一个时刻位置状态，例如让玩家保持之前的速度，动画继续“预测”运行一段时间，同时缓存此“预测”结果留做比对。</p>
<p>倘若当前客户端运行到第45帧，此时收到了服务器下发的第41帧信息，客户端会将之前“预测”的41帧信息与之做比对，确定预测是否正确</p>
<ul>
<li>若预测成功便抛弃这一帧的信息。</li>
<li>若预测失败，意味着之后的41到45帧都是错误的，则需要回滚到40帧，覆盖41帧重新运行这段时间更新数据更新画面表现，并追上当前时间</li>
</ul>
<p>既然要回滚到之前某一帧，就要保存当时玩家的操作和状态信息，被称作“快照(snapshot)”，某种程度上可以说是状态同步</p>
<p>不是所以信息客户端都需要进行预测，如UI血量等，需要预测的信息可以是击中特效，这对打击感的实现尤为重要</p>
<p><em>PS：想起以前玩CF，卡的时候对着僵尸突突突还有特效，几秒后角色便瞬移到另一个地方的。</em></p>
<h2 id="逻辑表示分离与插值">逻辑表示分离与插值 <a href="#%e9%80%bb%e8%be%91%e8%a1%a8%e7%a4%ba%e5%88%86%e7%a6%bb%e4%b8%8e%e6%8f%92%e5%80%bc" class="anchor">🔗</a></h2><p>帧有两种定义</p>
<ol>
<li>逻辑帧 Tick</li>
<li>渲染帧 Frame</li>
</ol>
<p>逻辑帧率和渲染帧率是互相独立的可以理解为Unity中Update和FixedUpdate的关系</p>
<p>一般服务器只同步逻辑帧，在客户端进行渲染帧的计算</p>
<p>由于客户端只负责一些模型、动画、位置信息，当收到服务器发送来的帧序列时，会根据该帧信息和当前状态进行插值，例如在速度、方向上进行插值。这样可以做到逻辑帧率和渲染帧率不一样，画面抖动和延迟感觉会降低</p>
<h2 id="守望先锋">《守望先锋》 <a href="#%e5%ae%88%e6%9c%9b%e5%85%88%e9%94%8b" class="anchor">🔗</a></h2><p>ECS架构</p>
<ul>
<li>Entity： Component的集合</li>
<li>Component： 只有数据，没有函数</li>
<li>System只： 有函数，没有状态</li>
</ul>
<p>通过ECS架构，可以尽量将网络同步和引擎部分解耦，System只需要遍历含有需要回滚的Component的Entity， 例如 NetworkEvent只遍历含有MovementState的Entity</p>
<ul>
<li>对需要回滚的组件进行快照式存储</li>
<li>通过这些组件实现对实体的增量式存储</li>
</ul>
<p><em>PS：守望先锋中维护了一个“脏”状态集合，我还没搞懂和ECS有什么联系。。。</em></p>
<h2 id="王者荣耀">《王者荣耀》 <a href="#%e7%8e%8b%e8%80%85%e8%8d%a3%e8%80%80" class="anchor">🔗</a></h2><ul>
<li>基于Unity 4.6</li>
<li>重新编写可靠传输的UDP</li>
<li>不使用帧buffer，收到帧数据后立即执行</li>
<li>逻辑与表现分离，逻辑部分使用C++重新编写</li>
<li>本地插值</li>
</ul>
<h2 id="参考">参考 <a href="#%e5%8f%82%e8%80%83" class="anchor">🔗</a></h2><ul>
<li><a href="http://mauve.mizuumi.net/2012/07/05/understanding-fighting-game-networking/" target="_blank" rel="noopener">Understanding Fighting Game Networking</a></li>
<li><a href="http://youxiputao.com/articles/11842" target="_blank" rel="noopener">《王者荣耀》复盘</a></li>
<li><a href="https://gameinstitute.qq.com/community/detail/114516" target="_blank" rel="noopener">《守望先锋》架构设计与网络同步</a></li>
<li><a href="https://mp.weixin.qq.com/s/cOGn8-rHWLIxdDz-R3pXDg" target="_blank" rel="noopener">《守望先锋》回放技术</a></li>
<li><a href="http://www.skywind.me/blog/archives/1343#more-1343" target="_blank" rel="noopener">再谈网游同步技术</a></li>
<li><a href="https://gafferongames.com/tags/networking/" target="_blank" rel="noopener">Glenn Fiedler</a></li>
</ul>
    </div>

    
    
    

</section>


    </main>
    
    <footer id="footer">
    
        <div id="social">


    <a class="symbol" href="your-github-link" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28"  viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    
    <title>Github</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)">
            <g id="Github" transform="translate(264.000000, 939.000000)">
                <path d="M8,72 L64,72 C68.418278,72 72,68.418278 72,64 L72,8 C72,3.581722 68.418278,-8.11624501e-16 64,0 L8,0 C3.581722,8.11624501e-16 -5.41083001e-16,3.581722 0,8 L0,64 C5.41083001e-16,68.418278 3.581722,72 8,72 Z" id="Rounded" fill="#bbbbbb"></path>
                <path d="M35.9985,13 C22.746,13 12,23.7870921 12,37.096644 C12,47.7406712 18.876,56.7718301 28.4145,59.9584121 C29.6145,60.1797862 30.0525,59.4358488 30.0525,58.7973276 C30.0525,58.2250681 30.0315,56.7100863 30.0195,54.6996482 C23.343,56.1558981 21.9345,51.4693938 21.9345,51.4693938 C20.844,48.6864054 19.2705,47.9454799 19.2705,47.9454799 C17.091,46.4500754 19.4355,46.4801943 19.4355,46.4801943 C21.843,46.6503662 23.1105,48.9634994 23.1105,48.9634994 C25.2525,52.6455377 28.728,51.5823398 30.096,50.9649018 C30.3135,49.4077535 30.9345,48.3460615 31.62,47.7436831 C26.2905,47.1352808 20.688,45.0691228 20.688,35.8361671 C20.688,33.2052792 21.6225,31.0547881 23.1585,29.3696344 C22.911,28.7597262 22.0875,26.3110578 23.3925,22.9934585 C23.3925,22.9934585 25.4085,22.3459017 29.9925,25.4632101 C31.908,24.9285993 33.96,24.6620468 36.0015,24.6515052 C38.04,24.6620468 40.0935,24.9285993 42.0105,25.4632101 C46.5915,22.3459017 48.603,22.9934585 48.603,22.9934585 C49.9125,26.3110578 49.089,28.7597262 48.8415,29.3696344 C50.3805,31.0547881 51.309,33.2052792 51.309,35.8361671 C51.309,45.0917119 45.6975,47.1292571 40.3515,47.7256117 C41.2125,48.4695491 41.9805,49.9393525 41.9805,52.1877301 C41.9805,55.4089489 41.9505,58.0067059 41.9505,58.7973276 C41.9505,59.4418726 42.3825,60.1918338 43.6005,59.9554002 C53.13,56.7627944 60,47.7376593 60,37.096644 C60,23.7870921 49.254,13 35.9985,13" fill="#FFFFFF"></path>
            </g>
        </g>
    </g>
</svg>
    </a>


</div>

    

    <div class="copyright">
    
       © Copyright 
       2023 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       nagisa
    
    </div>

    
</footer>



  </body>
</html>
