<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>自治的可移动游戏智能体 | Nostalgia</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="在近日的索尼 PlayStation “State of Play”上公布了许多新游戏，其中《Humanity》展现了模拟人类集体行为，效果非常震撼。">
<meta name="generator" content="Hugo 0.110.0">


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />

 
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'your-google-analytics-id', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	

	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">自治的可移动游戏智能体</h1>

    <div class="tip">
        <time datetime="2019-09-19 00:00:00 &#43;0000 UTC">Sep 19, 2019</time>
        <span class="split">
          ·
        </span>
        <span>
          2164 words
        </span>
        <span class="split">
          ·
        </span>
        <span>
          5 minute read
        </span>
    </div>

    
    
        
  
    <aside class="toc">
      <details>
          <summary>Table of Contents
          </summary>
          <div>
              <nav id="TableOfContents">
  <ul>
    <li><a href="#碰撞判断">碰撞判断</a></li>
    <li><a href="#vovelocity-obstacle">VO(Velocity Obstacle)</a></li>
    <li><a href="#rvoreciprocal-velocity-obstacle">RVO(Reciprocal Velocity Obstacle)</a></li>
    <li><a href="#触角feeler">触角(Feeler)</a></li>
  </ul>

  <ul>
    <li><a href="#fovfield-of-view">FOV(field of view)</a>
      <ul>
        <li><a href="#半径">半径</a></li>
        <li><a href="#视野">视野</a></li>
      </ul>
    </li>
    <li><a href="#alignment">Alignment</a></li>
    <li><a href="#cohesion">Cohesion</a></li>
    <li><a href="#separartion">Separartion</a></li>
    <li><a href="#wander">Wander</a></li>
    <li><a href="#领头者">领头者</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
          </div>
      </details>
    </aside>
  


    


    <div class="content">
      <p>在近日的索尼 PlayStation “State of Play”上公布了许多新游戏，其中<a href="https://youtu.be/ouHaVvmZ5uw" target="_blank" rel="noopener">《Humanity》</a>展现了模拟人类集体行为，效果非常震撼。</p>
<p>主要内容</p>
<ul>
<li>Obstacle Avoidance</li>
<li>Flocking</li>
</ul>
<h1 id="obstacle-avoidance">Obstacle Avoidance <a href="#obstacle-avoidance" class="anchor">🔗</a></h1><p>障碍物躲避属于路径规划中的底层算法，与此相对的高层算法有dijkstra,A*等</p>
<h2 id="碰撞判断">碰撞判断 <a href="#%e7%a2%b0%e6%92%9e%e5%88%a4%e6%96%ad" class="anchor">🔗</a></h2><p>为了便于计算，我们将角色视为质点，于此同时让障碍物的碰撞半径扩大角色自身宽度的一半</p>
<p><p class="markdown-image">
  <img src="/image/flocking/geogebra-export-2.png" alt="img"  />
</p></p>
<p>判断是否相交，其中$\vec{v}$ 为当前速度与预测时间$t$的乘积，$t$越大，感知的范围也越大，可以更早地避开障碍物，但更消耗性能</p>
<p><p class="markdown-image">
  <img src="/image/flocking/geogebra-export-3.png" alt="img"  />
</p></p>
<p>→pp→</p>
<p>$\vec{p}$为向量$\vec{a}$在速度$\vec{v}$上的投影，$\vec{b}=\vec{p}-\vec{a}$</p>
<p>当$|\vec{b}|-|\vec{r}|&lt;0$时，代表未来可能发生碰撞，这时需要给其添加两个力的作用，侧向操控力使其远离障碍物，与$\vec{b}$的大小成负相关，制动力使其减速，方向与当前速度相反，大小正比于$\vec{a}$</p>
<p><p class="markdown-image">
  <img src="/image/flocking/geogebra-export-5.png" alt="img"  />
</p></p>
<p>上述方法是通过施加力的作用避开障碍物，下面介绍的方法是改变速度</p>
<h2 id="vovelocity-obstacle">VO(Velocity Obstacle) <a href="#vovelocity-obstacle" class="anchor">🔗</a></h2><p>即：排除未来有可能会发生碰撞的速度</p>
<p><p class="markdown-image">
  <img src="/image/flocking/geogebra-export-4.png" alt="img"  />
</p></p>
<p>VO是指速度方向与B相交的部分，即会发生碰撞的部分（图中灰色部分)，VO会排除未来所有可能会发生碰撞的速度(例如$\vec{v_2}$在短时间内不会发生碰撞，但被舍弃了)</p>
<p>遇到可移动的障碍物时,直接求$\vec{V_A}$绝对速度的VO而不是$\vec{V_A-V_B}$相对速度的VO，将相对速度下的VO延→VBV→B方向平移，新的VO为右深色三角形区域</p>
<p><p class="markdown-image">
  <img src="/image/flocking/vo.png" alt="img"  />
</p></p>
<h2 id="rvoreciprocal-velocity-obstacle">RVO(Reciprocal Velocity Obstacle) <a href="#rvoreciprocal-velocity-obstacle" class="anchor">🔗</a></h2><p>VO的一个缺点是，当存在大量障碍物或可移动的障碍物时，会频繁改变速度产生抖动现象，例如当两个使用VO的物体相遇时，会产生左图的现象，RVO则是在VO基础上的优化(右图)</p>
<p><p class="markdown-image">
  <img src="/image/flocking/oscillation.png" alt="img"  />
</p></p>
<p>RVO的解决方案：缩小VO的大小以减少速度的突变</p>
<p><p class="markdown-image">
  <img src="/image/flocking/rvo.png" alt="img"  />
</p></p>
<p>从另一个方面会更好理解，不直接选择VO外的速度，而是选择当前速度与新速度的平均值，从某种程度上认为，对方也会做出相应回避行为，详细推导证明过程见<a href="http://gamma.cs.unc.edu/RVO//" target="_blank" rel="noopener">Reciprocal Velocity Obstacles for Real-Time Multi-Agent Navigation</a>有个有趣的问题是，当双方直面相遇时，如何避免双方选择相同的躲避方向？</p>
<p>还有一个优化算法是<a href="http://gamma.cs.unc.edu/ORCA/" target="_blank" rel="noopener">ORCA</a></p>
<h2 id="触角feeler">触角(Feeler) <a href="#%e8%a7%a6%e8%a7%92feeler" class="anchor">🔗</a></h2><p>模仿动物，我们还可以在物体前添加三根触角，分别测试他们是否和障碍物相交，其转向力与渗透深度成正比</p>
<p><p class="markdown-image">
  <img src="/image/flocking/01.png" alt="img"  />
</p></p>
<h1 id="flocking">Flocking <a href="#flocking" class="anchor">🔗</a></h1><p>群聚算法最早由Craig Reynolds 于1987 在SIGGRAPH上提出</p>
<blockquote>
<p>Flocks,Herds,and Schools: A Distributed Behavior Model</p>
</blockquote>
<p>其image是三个组行为的组合: separation(分离),alignment(对齐),cohesion(聚合)，你需要仔细调节它们间的权重以获得满意的群组行为，一个好的方法是使用势函数(potential function),在物理学中，它根据分子的接近程度产生引力和斥力，我们同样可以用在游戏单位身上</p>
<p>Lenard−Jones:U=−Arn+Brm</p>
<p><p class="markdown-image">
  <img src="/image/flocking/05.png" alt="Lenard-Jones"  />
</p></p>
<h2 id="fovfield-of-view">FOV(field of view) <a href="#fovfield-of-view" class="anchor">🔗</a></h2><p>首先，在一个组群中，每个单位都需要感知周围局部环境的情况，感知范围(视野)的确定对群体行为的影响很大</p>
<p><p class="markdown-image">
  <img src="/image/flocking/04.png" alt="img"  />
</p></p>
<h3 id="半径">半径 <a href="#%e5%8d%8a%e5%be%84" class="anchor">🔗</a></h3><ul>
<li>大半径容易产生凝聚性更强的群体，不容易发生落单现象</li>
<li>小半径容易让整个群体分裂，在绕过障碍物之后容易形成小群体</li>
</ul>
<h3 id="视野">视野 <a href="#%e8%a7%86%e9%87%8e" class="anchor">🔗</a></h3><ul>
<li>宽视角容易得到组织良好的群体,遇到障碍物时，群聚会倾向分开，从两边绕过障碍物，在某些情况下，他们会迅速重组，但某些情况下不会。</li>
<li>窄视野容易看起来有领导核心，单位倾向排成单一纵队平滑地绕过障碍物而不会分开。</li>
</ul>
<p><p class="markdown-image">
  <img src="/image/flocking/02.png" alt="img"  />
</p></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#080;font-style:italic">//获得周围单位，伪代码实现 </span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span>(unit <span style="color:#a2f;font-weight:bold">in</span> units){   
</span></span><span style="display:flex;"><span>	<span style="color:#a2f;font-weight:bold">if</span>(unit.distance&lt;radius &amp;&amp; unit.angle&lt;view){
</span></span><span style="display:flex;"><span>		neighbors.Add(unit);<span style="color:#080;font-style:italic">//使用容器存储</span>
</span></span><span style="display:flex;"><span>	} 
</span></span><span style="display:flex;"><span>} 
</span></span></code></pre></div><h2 id="alignment">Alignment <a href="#alignment" class="anchor">🔗</a></h2><p>每个单位行动时，都要把自己对齐在其临近单位的平均方向上</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span>(unit <span style="color:#a2f;font-weight:bold">in</span> neighbors){
</span></span><span style="display:flex;"><span>    Dir += unit.velocity.normalized;<span style="color:#080;font-style:italic">//对速度进行归一 </span>
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>avgDir = Dir / neighbors.lengths;<span style="color:#080;font-style:italic">//获得平均方向 </span>
</span></span><span style="display:flex;"><span>direction = (avgPos - self.position).normalized; 
</span></span><span style="display:flex;"><span>self.AddForce(direction - self.orward); 
</span></span></code></pre></div><h2 id="cohesion">Cohesion <a href="#cohesion" class="anchor">🔗</a></h2><p>每个单位都往临近单位的平均位置移动</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span> (unit <span style="color:#a2f;font-weight:bold">in</span> neighbors) { 
</span></span><span style="display:flex;"><span>    pos += unit.position; 
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>avgPos = pos / neighbors.lengths;<span style="color:#080;font-style:italic">//获得平均位置 </span>
</span></span><span style="display:flex;"><span>direction = (avgPos - self.position).normalized;
</span></span><span style="display:flex;"><span>self.AddForce(direction - self.forward);
</span></span></code></pre></div><h2 id="separartion">Separartion <a href="#separartion" class="anchor">🔗</a></h2><p>每个单位行动时，要避免撞上其临近单位</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span> (unit <span style="color:#a2f;font-weight:bold">in</span> neighbors) {
</span></span><span style="display:flex;"><span>    distance = unit.position - self.position;
</span></span><span style="display:flex;"><span>    force += Calulate(distance);<span style="color:#080;font-style:italic">//通过距离计算分离力，通常成反比 </span>
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>self.AddForce(force); 
</span></span></code></pre></div><h2 id="wander">Wander <a href="#wander" class="anchor">🔗</a></h2><p>有一个问题是，当一个单位和它的群组隔离了，它将什么都不做，为了防止这种情况发生，我们加入wander(徘徊)，这样所有的单位总可以保持运动。</p>
<p>最初的做法是产生一个随机的驱动力，但这会产生抖动(事实上，一个好的随机函数如Perlin噪声可以产生光滑转弯，但CPU开销会很大)，Reynolds的解决方案是在前端凸出个圆圈，目标被限制在该圆圈上，然后每帧在目标添加一个随机的位移，通过调整圆圈半径，距离和随机位移产生一个没有抖动的往复运动</p>
<p><p class="markdown-image">
  <img src="/image/flocking/03.png" alt="img"  />
</p></p>
<h2 id="领头者">领头者 <a href="#%e9%a2%86%e5%a4%b4%e8%80%85" class="anchor">🔗</a></h2><p>通过当前单位前方视野内的其他单位数量判断是否是领头者，也可以使用tag标记领头者，给他赋予单独的AI，一般领头者不太需要遵循上述群聚规则。</p>
<p>综合以上便可产生一些有趣的战术行为，例如，大半径窄视野并带有领头者的群组，就像秩序良好的突击队在半夜执行机密任务</p>
<p>事实上我们还有很多可以优化的地方，例如：</p>
<ol>
<li>对于突变的速度与方向，如何实现自然的转向</li>
<li>如何处理运动中不能后退和停止的物体，如飞行中的鸟</li>
<li>对于大量的群体，可以通过空间划分优化对临近单位的查找</li>
</ol>
<h2 id="参考">参考 <a href="#%e5%8f%82%e8%80%83" class="anchor">🔗</a></h2><ol>
<li><a href="https://www.red3d.com/cwr/steer/gdc99/" target="_blank" rel="noopener">Steering Behaviors For Autonomous Characters</a></li>
<li>《programming-game-ai-by-example》</li>
<li>《AI for game developers》</li>
</ol>
    </div>

    
    
    

</section>


    </main>
    
    <footer id="footer">
    
        <div id="social">


    <a class="symbol" href="your-github-link" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28"  viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    
    <title>Github</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)">
            <g id="Github" transform="translate(264.000000, 939.000000)">
                <path d="M8,72 L64,72 C68.418278,72 72,68.418278 72,64 L72,8 C72,3.581722 68.418278,-8.11624501e-16 64,0 L8,0 C3.581722,8.11624501e-16 -5.41083001e-16,3.581722 0,8 L0,64 C5.41083001e-16,68.418278 3.581722,72 8,72 Z" id="Rounded" fill="#bbbbbb"></path>
                <path d="M35.9985,13 C22.746,13 12,23.7870921 12,37.096644 C12,47.7406712 18.876,56.7718301 28.4145,59.9584121 C29.6145,60.1797862 30.0525,59.4358488 30.0525,58.7973276 C30.0525,58.2250681 30.0315,56.7100863 30.0195,54.6996482 C23.343,56.1558981 21.9345,51.4693938 21.9345,51.4693938 C20.844,48.6864054 19.2705,47.9454799 19.2705,47.9454799 C17.091,46.4500754 19.4355,46.4801943 19.4355,46.4801943 C21.843,46.6503662 23.1105,48.9634994 23.1105,48.9634994 C25.2525,52.6455377 28.728,51.5823398 30.096,50.9649018 C30.3135,49.4077535 30.9345,48.3460615 31.62,47.7436831 C26.2905,47.1352808 20.688,45.0691228 20.688,35.8361671 C20.688,33.2052792 21.6225,31.0547881 23.1585,29.3696344 C22.911,28.7597262 22.0875,26.3110578 23.3925,22.9934585 C23.3925,22.9934585 25.4085,22.3459017 29.9925,25.4632101 C31.908,24.9285993 33.96,24.6620468 36.0015,24.6515052 C38.04,24.6620468 40.0935,24.9285993 42.0105,25.4632101 C46.5915,22.3459017 48.603,22.9934585 48.603,22.9934585 C49.9125,26.3110578 49.089,28.7597262 48.8415,29.3696344 C50.3805,31.0547881 51.309,33.2052792 51.309,35.8361671 C51.309,45.0917119 45.6975,47.1292571 40.3515,47.7256117 C41.2125,48.4695491 41.9805,49.9393525 41.9805,52.1877301 C41.9805,55.4089489 41.9505,58.0067059 41.9505,58.7973276 C41.9505,59.4418726 42.3825,60.1918338 43.6005,59.9554002 C53.13,56.7627944 60,47.7376593 60,37.096644 C60,23.7870921 49.254,13 35.9985,13" fill="#FFFFFF"></path>
            </g>
        </g>
    </g>
</svg>
    </a>


</div>

    

    <div class="copyright">
    
       © Copyright 
       2023 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       nagisa
    
    </div>

    
</footer>



  </body>
</html>
