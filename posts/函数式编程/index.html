<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>函数式编程 | Nostalgia</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="先提出一个问题: 为什么C语言可以嵌套定义类,但是不能嵌套定义函数?
反过来我们可以想想: 如果可以在函数中定义函数会发生什么?">
<meta name="generator" content="Hugo 0.110.0">


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />

 
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'your-google-analytics-id', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>




  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>




  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	

	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">函数式编程</h1>

    <div class="tip">
        <time datetime="2019-12-14 00:00:00 &#43;0000 UTC">Dec 14, 2019</time>
        <span class="split">
          ·
        </span>
        <span>
          2926 words
        </span>
        <span class="split">
          ·
        </span>
        <span>
          6 minute read
        </span>
    </div>

    
    
        
  
    <aside class="toc">
      <details>
          <summary>Table of Contents
          </summary>
          <div>
              <nav id="TableOfContents">
  <ul>
    <li><a href="#匿名函数">匿名函数</a></li>
    <li><a href="#lambda表达式">lambda表达式</a></li>
    <li><a href="#闭包">闭包</a></li>
    <li><a href="#高阶函数">高阶函数</a></li>
    <li><a href="#科里化">科里化</a></li>
    <li><a href="#纯函数">纯函数</a></li>
    <li><a href="#函数式编程">函数式编程</a></li>
  </ul>

  <ul>
    <li><a href="#数值计算">数值计算</a></li>
    <li><a href="#类型计算">类型计算</a></li>
  </ul>
</nav>
          </div>
      </details>
    </aside>
  


    


    <div class="content">
      <p>先提出一个问题: <strong>为什么C语言可以嵌套定义类,但是不能嵌套定义函数?</strong></p>
<p>反过来我们可以想想: <strong>如果可以在函数中定义函数会发生什么?</strong></p>
<p>主要内容</p>
<ul>
<li>匿名函数、lambda表达式</li>
<li>闭包</li>
<li>高阶函数、科里化</li>
<li>纯函数</li>
<li>函数式编程</li>
<li>模板元编程</li>
</ul>
<p>C#，C++11通过支持Lambda表达式(本质上是匿名类)来实现类似功能</p>
<h2 id="匿名函数">匿名函数 <a href="#%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0" class="anchor">🔗</a></h2><p>简化程序中使用次数少的函数，不用显式定义函数名，但编译期还是会在背后定义，是一种语法糖（其实还有匿名类…）</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#080;font-style:italic">//C# 使用关键字delegate,表示一个参数为(int, double) 返回值为double 的函数 </span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">delegate</span> <span style="color:#0b0;font-weight:bold">double</span> (<span style="color:#0b0;font-weight:bold">int</span> a,<span style="color:#0b0;font-weight:bold">double</span> b) { <span style="color:#a2f;font-weight:bold">return</span> a + b ; }
</span></span></code></pre></div><h2 id="lambda表达式">lambda表达式 <a href="#lambda%e8%a1%a8%e8%be%be%e5%bc%8f" class="anchor">🔗</a></h2><p>匿名函数的进步一简化</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#080;font-style:italic">//与匿名函数相同,但是可以省略delegate和其他符号(有限制) </span>
</span></span><span style="display:flex;"><span>(<span style="color:#0b0;font-weight:bold">int</span> x,<span style="color:#0b0;font-weight:bold">double</span> y) =&gt; { <span style="color:#a2f;font-weight:bold">return</span> x * y; }	<span style="color:#080;font-style:italic">//自动推断返回值类型 x =&gt; x+5; </span>
</span></span><span style="display:flex;"><span>() =&gt; PI;		<span style="color:#080;font-style:italic">//返回常量</span>
</span></span></code></pre></div><p>用途</p>
<ul>
<li>委托</li>
<li>LINQ</li>
</ul>
<h2 id="闭包">闭包 <a href="#%e9%97%ad%e5%8c%85" class="anchor">🔗</a></h2><p>捕获变量</p>
<p>闭包会延长它使用的外部变量的生命周期，直到闭包本身被释放,不会被垃圾回收</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span>Func&lt;<span style="color:#0b0;font-weight:bold">int</span>&gt; T1() { 
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> i = <span style="color:#666">0</span>;                      <span style="color:#080;font-style:italic">//i是局部变量,应该分配在栈上 </span>
</span></span><span style="display:flex;"><span>    Func&lt;<span style="color:#0b0;font-weight:bold">int</span>&gt; T2 = () =&gt; ++i;       <span style="color:#080;font-style:italic">//捕获了外部变量i return T2; //i的作用范围结束,i应该消失 </span>
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">var</span> s = T1(); 
</span></span><span style="display:flex;"><span>s();			<span style="color:#080;font-style:italic">//i = 1 </span>
</span></span><span style="display:flex;"><span>s();			<span style="color:#080;font-style:italic">//i = 2 </span>
</span></span></code></pre></div><p>.NET本身并不支持函数对象，它依然满足对象生命周期的规则。编译器在背后会生成一个类,将局部变量i变成该类的一个属性，从而保证了变量的生命周期不会随函数T1调用结束而结束。</p>
<p>C#中，闭包其实和类中其他属性、方法是一样的。它们的原则都是下一层可以调用上一层定义，但上一层则不具备访问下一层设定的能力。即类中方法里的变量可以自由访问类中的所有属性和方法，而闭包又可以访问它的上一层即方法中的各种设定，但类不可以访问方法的局部变量。同理，方法也不可以访问其内部定义的匿名函数所定义的局部变量。</p>
<p><strong>延迟调用</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span>List&lt;Func&lt;<span style="color:#0b0;font-weight:bold">int</span>&gt;&gt; funcs = <span style="color:#a2f;font-weight:bold">new</span> List&lt;Func&lt;<span style="color:#0b0;font-weight:bold">int</span>&gt;&gt;(); 
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> i = <span style="color:#666">0</span>; i &lt; <span style="color:#666">3</span>; i++) {
</span></span><span style="display:flex;"><span>    funcs.Add(() =&gt; { <span style="color:#a2f;font-weight:bold">return</span> i; }); 
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">foreach</span>(<span style="color:#0b0;font-weight:bold">var</span> item <span style="color:#a2f;font-weight:bold">in</span> funcs) { 
</span></span><span style="display:flex;"><span>    Console.WriteLine(item().ToString());		<span style="color:#080;font-style:italic">// 3,3,3 </span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="高阶函数">高阶函数 <a href="#%e9%ab%98%e9%98%b6%e5%87%bd%e6%95%b0" class="anchor">🔗</a></h2><p>函数可以接受另一个函数作为输入参数，同时也可以返回一个函数</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// 使用LINQ查询出数组中的奇数 </span>
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span>[] ints = { <span style="color:#666">5</span>, <span style="color:#666">2</span>, <span style="color:#666">0</span>, <span style="color:#666">66</span>, <span style="color:#666">4</span>, <span style="color:#666">32</span>, <span style="color:#666">7</span>, <span style="color:#666">1</span> }; 
</span></span><span style="display:flex;"><span>List&lt;<span style="color:#0b0;font-weight:bold">int</span>&gt; list = IntExtension.<span style="color:#a2f;font-weight:bold">where</span>(ints, (item) =&gt; item % <span style="color:#666">2</span> != <span style="color:#666">0</span>;).ToList(); <span style="color:#080;font-style:italic">//等同与下面代码</span>
</span></span><span style="display:flex;"><span>List[] Find(<span style="color:#0b0;font-weight:bold">int</span>[] ints, Func&lt;<span style="color:#0b0;font-weight:bold">int</span>,<span style="color:#0b0;font-weight:bold">bool</span>&gt; check){  
</span></span><span style="display:flex;"><span>    List[] result;  
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">foreach</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#a2f;font-weight:bold">in</span> ints){
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(check(i) == <span style="color:#a2f;font-weight:bold">true</span>){      
</span></span><span style="display:flex;"><span>            result.Add(i);    
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> result; 
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">bool</span> Check(<span style="color:#0b0;font-weight:bold">int</span> item){  
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(item % <span style="color:#666">2</span> != <span style="color:#666">0</span>) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f;font-weight:bold">true</span>; 
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>Find(ints,Check);	<span style="color:#080;font-style:italic">//将函数Check传入函数Find,类似函数指针</span>
</span></span></code></pre></div><h2 id="科里化">科里化 <a href="#%e7%a7%91%e9%87%8c%e5%8c%96" class="anchor">🔗</a></h2><p>Currying就是将需要多个参数的函数转换为「接受一个参数；返回一个值」的函数</p>
<p>实现方法: 当提供较少的参数时，返回一个等待剩余参数的新函数</p>
<p>好处:</p>
<ol>
<li>参数可复用，对部分参数的复用,无需重复添加</li>
<li>可以提前返回，存在返回值，并且可以继续接收参数的函数</li>
<li>延迟运行，不断的柯里化，累积传入的参数，最后执行</li>
</ol>
<p>这样对于讨论和优化会更加方便。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// 原函数 </span>
</span></span><span style="display:flex;"><span>function <span style="color:#a2f;font-weight:bold">add</span>(a, b, c) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> a + b + c; 
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// 柯里化函数 </span>
</span></span><span style="display:flex;"><span>function addCurrying(a) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> function (b) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> function (c) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">return</span> a + b + c;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// 调用原函数</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">add</span>(<span style="color:#666">1</span>, <span style="color:#666">2</span>, <span style="color:#666">3</span>); <span style="color:#080;font-style:italic">// 6</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">// 调用柯里化函数 </span>
</span></span><span style="display:flex;"><span>addCurrying(<span style="color:#666">1</span>)(<span style="color:#666">2</span>)(<span style="color:#666">3</span>) <span style="color:#080;font-style:italic">// 6 </span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">//参数复用 </span>
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">var</span> add1 = <span style="color:#a2f;font-weight:bold">add</span>(<span style="color:#666">1</span>); 
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">var</span> add2 = <span style="color:#a2f;font-weight:bold">add</span>(<span style="color:#666">2</span>); 
</span></span><span style="display:flex;"><span>add1(<span style="color:#666">3</span>);	
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">//1+3 add2(3);	//2+3 </span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">//延迟计算 </span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">add</span>(<span style="color:#666">1</span>,<span style="color:#666">2</span>)(<span style="color:#666">3</span>); 
</span></span><span style="display:flex;"><span>ad(<span style="color:#666">4</span>); 
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">add</span>(); <span style="color:#080;font-style:italic">// 10 </span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">//经过修改还可以接受任意数量的参数 </span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">add</span>(<span style="color:#666">1</span>, <span style="color:#666">2</span>, <span style="color:#666">3</span>, <span style="color:#666">4</span>)(<span style="color:#666">5</span>)	<span style="color:#080;font-style:italic">// 15 </span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">add</span>(<span style="color:#666">1</span>, <span style="color:#666">2</span>)(<span style="color:#666">3</span>, <span style="color:#666">4</span>)		<span style="color:#080;font-style:italic">// 10 </span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">add</span>(<span style="color:#666">1</span>, <span style="color:#666">2</span>)(<span style="color:#666">3</span>)(<span style="color:#666">4</span>)		<span style="color:#080;font-style:italic">// 10</span>
</span></span></code></pre></div><h2 id="纯函数">纯函数 <a href="#%e7%ba%af%e5%87%bd%e6%95%b0" class="anchor">🔗</a></h2><ol>
<li>当参数相同时，永远返回相同的结果，并且不依赖于任何外部状态或数据</li>
<li>函数不会发生任何突变(mutation)或产生任何副作用(side effect)，如修改外部状态</li>
</ol>
<p>优点:</p>
<ol>
<li>简洁，容易阅读</li>
<li>易于并发编程，不需要考虑死锁(deadlock)</li>
<li>测试方便</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// 函数内部使用的变量是显式传递进去的 </span>
</span></span><span style="display:flex;"><span>function f(x){  
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> function g(x){
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">//g(x)是会依靠f(x)的参数返回的,g(x)相当于拥有f(x)的闭包   </span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> x * x;  
</span></span><span style="display:flex;"><span>    } 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>问:纯函数式的闭包和不改变函数状态的特性是否矛盾</strong></p>
<p>闭包虽然可以把闭包外部的变量捕获到闭包内部，但是闭包还是满足不改变状态的特性的。</p>
<p>虽然传入了不同参数，但是闭包里面的整体算法是没有变化的。g(x)虽然每次都会由f(x)传入的x值变化而变化，但是g(x)整体算法就是计算x的平方，这个计算方法是没有变化的，不根据外部状态改变而改变的。</p>
<h2 id="函数式编程">函数式编程 <a href="#%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b" class="anchor">🔗</a></h2><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span>(<span style="color:#666">1</span> + <span style="color:#666">2</span>) * <span style="color:#666">3</span> - <span style="color:#666">4</span> 
</span></span><span style="display:flex;"><span>subtract(multiply(<span style="color:#a2f;font-weight:bold">add</span>(<span style="color:#666">1</span>,<span style="color:#666">2</span>), <span style="color:#666">3</span>), <span style="color:#666">4</span>) 
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">add</span>(<span style="color:#666">1</span>,<span style="color:#666">2</span>).multiply(<span style="color:#666">3</span>).subtract(<span style="color:#666">4</span>)
</span></span></code></pre></div><ol>
<li>
<p>函数是“第一等公民”(first class)</p>
<p>函数与其他数据类型一样,可以赋值给其他变量，也可以作为其他函数的参数和返回值</p>
</li>
<li>
<p>使用“表达式”代替“语句”</p>
<p>表达式(expression)是一个单纯的运算过程，总是有返回值；语句(statement)是执行某种操作如赋值，没有返回值。函数式编程要求每一步都是单纯的运算，而且都有返回值</p>
</li>
<li>
<p>没有&quot;副作用”</p>
<p>函数式编程强调没有&quot;副作用”，所有功能就是返回一个新的值，没有其他行为如修改外部变量的值。</p>
</li>
<li>
<p>不修改“状态”</p>
<p>通常用变量来保存&quot;状态”(state), 但在函数式编程中常使用递归参数保存状态</p>
</li>
<li>
<p>引用透明(Referential transparency)</p>
<p>函数的运行不依赖于外部变量或&quot;状态”，只依赖于输入的参数，任何时候只要参数相同，得到的返回值总是相同的</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">var</span> c = <span style="color:#666">10</span>; 
</span></span><span style="display:flex;"><span>function addC(a, b) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> a + b + c; 
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>addC(<span style="color:#666">1</span>,<span style="color:#666">2</span>)		<span style="color:#080;font-style:italic">//1+2+10; </span>
</span></span><span style="display:flex;"><span>addC(<span style="color:#666">3</span>,<span style="color:#666">4</span>)		<span style="color:#080;font-style:italic">//3+4+10; </span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">//改变c </span>
</span></span><span style="display:flex;"><span>addC(<span style="color:#666">1</span>,<span style="color:#666">2</span>)		
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">//1+2+10 </span>
</span></span><span style="display:flex;"><span>c=<span style="color:#666">20</span>; 
</span></span><span style="display:flex;"><span>addC(<span style="color:#666">1</span>,<span style="color:#666">2</span>)		<span style="color:#080;font-style:italic">//1+2+20 </span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">//C就成为了一种状态(State)，它的变化可以左右函数的输出,也就是产生副作用,再来看下面一个例子 </span>
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">var</span> c = <span style="color:#666">10</span>; 
</span></span><span style="display:flex;"><span>function addC(a,b){
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> a + b + (c++); 
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>addC(<span style="color:#666">1</span>, <span style="color:#666">2</span>)	<span style="color:#080;font-style:italic">//1+2+10; </span>
</span></span><span style="display:flex;"><span>addC(<span style="color:#666">1</span>, <span style="color:#666">2</span>)		<span style="color:#080;font-style:italic">//1+2+11;改变了状态</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">//不同时间调用add()产生的结果不同 </span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">//将输出仅取决于输入的参数</span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">//将语句 c = 10 变成表达式 </span>
</span></span><span style="display:flex;"><span>function getC(){
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">10</span> 
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>function addC(a, b) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> a + b + getC()  	
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">//return a + b + 10 </span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">//输出仅取决于输入的参数。 </span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">//不修改状态意味着我们就不使用赋值和变量了吗? </span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">//抛弃了“=” </span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">//不使用状态如何控制程序运行顺序? </span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">//计算累加 </span>
</span></span><span style="display:flex;"><span>function countSum (num) {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">var</span> result = <span style="color:#666">0</span>		
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">//var i 作为状态(state)控制了函数内部的循环,但它还是一个纯函数    </span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">var</span> i = <span style="color:#666">1</span>; i &lt; num; i ++) {
</span></span><span style="display:flex;"><span>            result += i    
</span></span><span style="display:flex;"><span>        }    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> result 
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>function countSum (num) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> num = <span style="color:#666">1</span> ? <span style="color:#666">1</span> : num + countSum(num-<span style="color:#666">1</span>)		<span style="color:#080;font-style:italic">//通过递归,使用函数参数保存状态 </span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="模板元编程">模板元编程 <a href="#%e6%a8%a1%e6%9d%bf%e5%85%83%e7%bc%96%e7%a8%8b" class="anchor">🔗</a></h1><p>C++ 模板元编程不是设计之初的功能，是意外发现的“黑魔法”，它用来编写编译期运行的程序，也就是可以将运行期间的计算转化为编译期的计算</p>
<h2 id="数值计算">数值计算 <a href="#%e6%95%b0%e5%80%bc%e8%ae%a1%e7%ae%97" class="anchor">🔗</a></h2><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">template</span><span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span> N, <span style="color:#0b0;font-weight:bold">int</span> M<span style="color:#666">&gt;</span> <span style="color:#a2f;font-weight:bold">struct</span> <span style="color:#00f">meta_Add</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">static</span> <span style="color:#a2f;font-weight:bold">const</span> <span style="color:#0b0;font-weight:bold">int</span> value <span style="color:#666">=</span> N <span style="color:#666">+</span> M; 
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span>meta_Add<span style="color:#666">&lt;</span><span style="color:#666">1</span>, <span style="color:#666">2</span><span style="color:#666">&gt;::</span>value		<span style="color:#080;font-style:italic">//3
</span></span></span></code></pre></div><p>模版元程序在编译期执行，不能使用运行期间的if-else、for、while等语句，但可以通过递归形式实现循环，通过模板特例化实现条件判断，这两点使得其具有和普通语言一样通用的能力（图灵完备性）。</p>
<p>从编程范式上来说，C++模板元编程是函数式编程</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">template</span><span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span> N<span style="color:#666">&gt;</span> <span style="color:#a2f;font-weight:bold">struct</span> <span style="color:#00f">meta_Sum</span>{    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">enum</span> { Result <span style="color:#666">=</span> meta<span style="color:#666">-</span>Sum<span style="color:#666">&lt;</span>N<span style="color:#666">-</span><span style="color:#666">1</span><span style="color:#666">&gt;::</span>Result <span style="color:#666">+</span> N }; 
</span></span><span style="display:flex;"><span>}; 
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">template</span> <span style="color:#666">&lt;&gt;</span>			<span style="color:#080;font-style:italic">//特化 struct meta_Sum&lt;1&gt;{    enum { Result = 1 }; };
</span></span></span></code></pre></div><h2 id="类型计算">类型计算 <a href="#%e7%b1%bb%e5%9e%8b%e8%ae%a1%e7%ae%97" class="anchor">🔗</a></h2><p>数值计算在模板元编程中用的很少，真正有价值的是类型计算，通过模板提供的参数化的类型，可以补充C++自带的类型，使得类型系统更加智能与完备。一般来说在运行期发生的类型错误很难发现和调试。通过模板元编程，在编译期就可以对类型进行检查，从而避免运行期出错。</p>
<p>一个典型的例子是物理量计算的量纲问题</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">typedef</span> tyVector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#666">1</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span><span style="color:#666">&gt;</span> Length;	<span style="color:#080;font-style:italic">//长度,单位m 
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">typedef</span> tyVector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#666">0</span>, <span style="color:#666">1</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span><span style="color:#666">&gt;</span> Mass;	<span style="color:#080;font-style:italic">//质量,单位kg 
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">typedef</span> tyVector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">1</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span><span style="color:#666">&gt;</span> Time;	<span style="color:#080;font-style:italic">//时间,单位s 
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">typedef</span> tyVector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">1</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span><span style="color:#666">&gt;</span> I;		<span style="color:#080;font-style:italic">//电流,单位A 
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">typedef</span> tyVector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">1</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span><span style="color:#666">&gt;</span> K;		<span style="color:#080;font-style:italic">//热力学温度,单位K 
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">typedef</span> tyVector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">1</span>, <span style="color:#666">0</span><span style="color:#666">&gt;</span> n;		<span style="color:#080;font-style:italic">//物质的量,单位mol 
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">typedef</span> tyVector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">1</span><span style="color:#666">&gt;</span> lv;		<span style="color:#080;font-style:italic">//发光强度,单位cd 
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">auto</span> velocity<span style="color:#666">=</span>{<span style="color:#666">1</span>,<span style="color:#666">0</span>,<span style="color:#666">-</span><span style="color:#666">1</span>,<span style="color:#666">0</span>,<span style="color:#666">0</span>,<span style="color:#666">0</span>,<span style="color:#666">0</span>}; 
</span></span><span style="display:flex;"><span>tymeta<span style="color:#666">::</span>quantity<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">float</span>, tymeta<span style="color:#666">::</span>Length<span style="color:#666">&gt;</span> len(<span style="color:#666">10.23</span>);		<span style="color:#080;font-style:italic">//长度 
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>tymeta<span style="color:#666">::</span>quantity<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">float</span>, tymeta<span style="color:#666">::</span>Time<span style="color:#666">&gt;</span> t(<span style="color:#666">5</span>);				<span style="color:#080;font-style:italic">//时间 
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>tymeta<span style="color:#666">::</span>quantity<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">float</span>, tymeta<span style="color:#666">::</span>Mass<span style="color:#666">&gt;</span> m(<span style="color:#666">10</span>);			<span style="color:#080;font-style:italic">//质量 
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">auto</span> speed <span style="color:#666">=</span> len <span style="color:#666">/</span> t;			<span style="color:#080;font-style:italic">//速度 //类型为quantity&lt;float,struct  tymeta::tyVector&lt;int,1,0,-1,0,0,0,0&gt;&gt; 
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">auto</span> a_speed <span style="color:#666">=</span> speed <span style="color:#666">/</span> t;	<span style="color:#080;font-style:italic">//加速度 //类型为quantity&lt;float,struct tymeta::tyVector&lt;int,1,0,-2,0,0,0,0&gt;&gt; 
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">auto</span> force <span style="color:#666">=</span> a_speed <span style="color:#666">*</span> m;	<span style="color:#080;font-style:italic">//力 //类型为quantity&lt;float,struct tymeta::tyVector&lt;int,1,1,-2,0,0,0,0&gt;&gt; 
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">//但一旦出现 
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">auto</span> r <span style="color:#666">=</span> force <span style="color:#666">+</span> speed; 
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">//会得到一个编译期的错误
</span></span></span></code></pre></div>
    </div>

    
    
    

</section>


    </main>
    
    <footer id="footer">
    
        <div id="social">


    <a class="symbol" href="your-github-link" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28"  viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    
    <title>Github</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)">
            <g id="Github" transform="translate(264.000000, 939.000000)">
                <path d="M8,72 L64,72 C68.418278,72 72,68.418278 72,64 L72,8 C72,3.581722 68.418278,-8.11624501e-16 64,0 L8,0 C3.581722,8.11624501e-16 -5.41083001e-16,3.581722 0,8 L0,64 C5.41083001e-16,68.418278 3.581722,72 8,72 Z" id="Rounded" fill="#bbbbbb"></path>
                <path d="M35.9985,13 C22.746,13 12,23.7870921 12,37.096644 C12,47.7406712 18.876,56.7718301 28.4145,59.9584121 C29.6145,60.1797862 30.0525,59.4358488 30.0525,58.7973276 C30.0525,58.2250681 30.0315,56.7100863 30.0195,54.6996482 C23.343,56.1558981 21.9345,51.4693938 21.9345,51.4693938 C20.844,48.6864054 19.2705,47.9454799 19.2705,47.9454799 C17.091,46.4500754 19.4355,46.4801943 19.4355,46.4801943 C21.843,46.6503662 23.1105,48.9634994 23.1105,48.9634994 C25.2525,52.6455377 28.728,51.5823398 30.096,50.9649018 C30.3135,49.4077535 30.9345,48.3460615 31.62,47.7436831 C26.2905,47.1352808 20.688,45.0691228 20.688,35.8361671 C20.688,33.2052792 21.6225,31.0547881 23.1585,29.3696344 C22.911,28.7597262 22.0875,26.3110578 23.3925,22.9934585 C23.3925,22.9934585 25.4085,22.3459017 29.9925,25.4632101 C31.908,24.9285993 33.96,24.6620468 36.0015,24.6515052 C38.04,24.6620468 40.0935,24.9285993 42.0105,25.4632101 C46.5915,22.3459017 48.603,22.9934585 48.603,22.9934585 C49.9125,26.3110578 49.089,28.7597262 48.8415,29.3696344 C50.3805,31.0547881 51.309,33.2052792 51.309,35.8361671 C51.309,45.0917119 45.6975,47.1292571 40.3515,47.7256117 C41.2125,48.4695491 41.9805,49.9393525 41.9805,52.1877301 C41.9805,55.4089489 41.9505,58.0067059 41.9505,58.7973276 C41.9505,59.4418726 42.3825,60.1918338 43.6005,59.9554002 C53.13,56.7627944 60,47.7376593 60,37.096644 C60,23.7870921 49.254,13 35.9985,13" fill="#FFFFFF"></path>
            </g>
        </g>
    </g>
</svg>
    </a>


</div>

    

    <div class="copyright">
    
       © Copyright 
       2023 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       nagisa
    
    </div>

    
</footer>



  </body>
</html>
